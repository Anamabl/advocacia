import datetime
import json
import os

# Nome do arquivo onde os dados ser√£o persistidos
DATA_FILE = "tarefas.json"

# Defini√ß√£o da ordem num√©rica das prioridades para fins de ordena√ß√£o
ORDEM_PRIORIDADE = {"Urgente": 0, "Alta": 1, "Media": 2, "Baixa": 3}

# --- Fun√ß√µes de Persist√™ncia e Utilit√°rios ---

def carregar_tarefas():
    """Carrega as tarefas do arquivo JSON. Retorna lista vazia se o arquivo n√£o existir ou estiver corrompido."""
    if not os.path.exists(DATA_FILE):
        return []
    
    with open(DATA_FILE, "r", encoding="utf-8") as f:
        try:
            # Carrega o conte√∫do do JSON
            return json.load(f)
        except json.JSONDecodeError:
            print("üö® Arquivo de dados corrompido. Iniciando com lista vazia.")
            return []

def salvar_tarefas(tarefas):
    """Salva a lista completa de tarefas no arquivo JSON."""
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        # Usa indent=2 para formatar o JSON de forma leg√≠vel
        json.dump(tarefas, f, ensure_ascii=False, indent=2)

def proximo_id(tarefas):
    """Calcula o pr√≥ximo ID sequencial baseado nos IDs existentes."""
    if not tarefas:
        return 1
    # Garante que mesmo tarefas sem 'id' n√£o causem erro no c√°lculo do m√°ximo
    return max(t.get("id", 0) for t in tarefas) + 1

# --- Fun√ß√µes de Valida√ß√£o de Entrada ---

def ler_data(prompt):
    """L√™ e valida a entrada de data no formato AAAA-MM-DD."""
    while True:
        s = input(prompt).strip()
        try:
            # Tenta criar um objeto date para validar o formato
            datetime.date.fromisoformat(s)
            return s  # Retorna a string ISO formatada
        except ValueError:
            print("‚ùå Formato de data inv√°lido. Use AAAA-MM-DD.")

def ler_prioridade(prompt):
    """L√™ e valida a prioridade, aceitando apenas valores v√°lidos."""
    while True:
        p = input(prompt).strip().capitalize()
        if p in ORDEM_PRIORIDADE:
            return p
        print(f"‚ùå Prioridade inv√°lida. Use: {', '.join(ORDEM_PRIORIDADE.keys())}.")

# --- Fun√ß√µes de L√≥gica de Neg√≥cio ---

def adicionar_tarefa(tarefas):
    """Permite ao usu√°rio adicionar uma nova tarefa √† lista."""
    print("\n--- ‚ûï Adicionar Nova Tarefa ---")
    
    while True:
        descricao = input("Descri√ß√£o da Tarefa: ").strip()
        if descricao:
            break
        print("Descri√ß√£o n√£o pode ficar vazia.")
        
    processo = input("N¬∫ do Processo (ou ref.) [opcional]: ").strip()
    prazo_iso = ler_data("Prazo Final (AAAA-MM-DD): ")
    prioridade = ler_prioridade("Prioridade (Urgente/Alta/Media/Baixa): ")
    
    nova = {
        "id": proximo_id(tarefas),
        "descricao": descricao,
        "processo_num": processo,
        "prazo": prazo_iso,
        "prioridade": prioridade,
        "concluida": False,
        "criada_em": datetime.date.today().isoformat()
    }
    
    tarefas.append(nova)
    salvar_tarefas(tarefas)
    print(f"\n‚úÖ Tarefa '{descricao}' adicionada (ID: {nova['id']}).")

def ordenar_tarefas_para_apresentacao(lista):
    """Ordena a lista de tarefas, priorizando por Prazo e, em seguida, por Prioridade."""
    
    def chave(t):
        try:
            # Converte o prazo para um objeto date para compara√ß√£o correta
            prazo = datetime.date.fromisoformat(t.get("prazo"))
        except Exception:
            # Coloca tarefas sem prazo v√°lido no final
            prazo = datetime.date.max 
            
        # Prioridade num√©rica (0=Urgente, 3=Baixa)
        prioridade_ord = ORDEM_PRIORIDADE.get(t.get("prioridade", ""), 99)
        
        return (prazo, prioridade_ord)
        
    return sorted(lista, key=chave)

def exibir_tarefas(tarefas, filtro="ativas"):
    """Exibe as tarefas com base no filtro (ativas, conclu√≠das ou todas), aplicando a ordena√ß√£o."""
    
    if filtro == "ativas":
        subset = [t for t in tarefas if not t.get("concluida", False)]
        titulo = "Tarefas Ativas (ordenadas por prazo/prioridade)"
    elif filtro == "concluidas":
        subset = [t for t in tarefas if t.get("concluida", False)]
        titulo = "Tarefas Conclu√≠das"
    else:
        subset = tarefas
        titulo = "Todas as Tarefas"

    if not subset:
        print("\nüìù Nenhuma tarefa encontrada para este filtro.")
        return

    ordenadas = ordenar_tarefas_para_apresentacao(subset)
    print(f"\n--- {titulo} ({len(subset)} itens) ---")
    
    hoje = datetime.date.today()
    for t in ordenadas:
        
        # C√°lculo e Status do Prazo
        status_prazo = ""
        try:
            prazo_dt = datetime.date.fromisoformat(t.get("prazo"))
            dias = (prazo_dt - hoje).days
            if t.get("concluida"):
                status_prazo = "‚úÖ (Conclu√≠da)"
            elif dias < 0:
                status_prazo = f"üö® (PRAZO VENCIDO h√° {-dias} dias!)"
            else:
                status_prazo = f"‚è≥ ({dias} dias restantes)"
        except Exception:
            status_prazo = "‚ùì (Prazo n√£o definido)"
            
        # Formata√ß√£o de Exibi√ß√£o
        sinal = "X" if t.get("concluida") else " "
        
        print(f"ID {t['id']:>3} [{sinal}] [P:{t.get('prioridade','?')}] {t.get('descricao')}")
        
        proc = t.get("processo_num")
        if proc:
            print(f"    Processo: {proc}")
            
        print(f"    Prazo: {t.get('prazo')} {status_prazo}")
        
        if t.get("concluida") and t.get("concluida_em"):
            print(f"    Conclu√≠da em: {t.get('concluida_em')}")
        print("-" * 50)

def marcar_concluida(tarefas):
    """Marca uma tarefa ativa como conclu√≠da e registra a data."""
    exibir_tarefas(tarefas, filtro="ativas")
    
    if not [t for t in tarefas if not t.get("concluida", False)]:
        return
        
    try:
        s = input("\nDigite o ID da tarefa para marcar como CONCLU√çDA: ").strip()
        id_selecionado = int(s)
    except ValueError:
        print("‚ùå ID inv√°lido.")
        return
        
    for t in tarefas:
        if t.get("id") == id_selecionado and not t.get("concluida", False):
            t["concluida"] = True
            t["concluida_em"] = datetime.date.today().isoformat()
            salvar_tarefas(tarefas)
            print(f"‚úÖ Tarefa ID {id_selecionado} ({t.get('descricao')}) marcada como conclu√≠da.")
            return
            
    print("‚ùå Nenhuma tarefa ativa encontrada com esse ID.")

def remover_tarefa(tarefas):
    """Remove uma tarefa do arquivo de dados permanentemente."""
    exibir_tarefas(tarefas, filtro="todas")
    
    if not tarefas:
        return

    try:
        s = input("\nDigite o ID da tarefa para REMOVER (permanente): ").strip()
        id_sel = int(s)
    except ValueError:
        print("‚ùå ID inv√°lido.")
        return
        
    for idx, t in enumerate(tarefas):
        if t.get("id") == id_sel:
            confirma = input(f"‚ùó Confirma remo√ß√£o da tarefa '{t.get('descricao')}'? (s/N): ").strip().lower()
            if confirma == "s":
                tarefas.pop(idx)
                salvar_tarefas(tarefas)
                print("üóëÔ∏è Tarefa removida permanentemente.")
            else:
                print("Remo√ß√£o cancelada.")
            return
            
    print("‚ùå ID n√£o encontrado.")

# --- Menu Principal ---

def menu_principal():
    """Fun√ß√£o principal que gerencia o fluxo do programa."""
    tarefas = carregar_tarefas()

    # Se a lista estiver vazia e o arquivo n√£o existir, adiciona exemplos para demonstra√ß√£o
    if not tarefas and not os.path.exists(DATA_FILE):
        print("\n[Inicializa√ß√£o] Adicionando tarefas de exemplo...")
        tarefas.extend([
            {'id': proximo_id(tarefas), 'descricao': 'Analisar jurisprud√™ncia do TJ-SP para caso Z', 'prazo': '2025-10-25', 'processo_num': '0001', 'prioridade': 'Alta', 'concluida': False, 'criada_em': '2025-10-28'},
            {'id': proximo_id(tarefas), 'descricao': 'Protocolar defesa do cliente Silva - Prazo final!', 'prazo': '2025-10-29', 'processo_num': '0002', 'prioridade': 'Urgente', 'concluida': False, 'criada_em': '2025-10-28'},
            {'id': proximo_id(tarefas), 'descricao': 'Organizar arquivos f√≠sicos de 2024', 'prazo': '2026-01-30', 'processo_num': 'ADM-001', 'prioridade': 'Baixa', 'concluida': False, 'criada_em': '2025-10-28'},
        ])
        salvar_tarefas(tarefas)

    while True:
        print("\n" + "="*40)
        print("  ‚öñÔ∏è GEST√ÉO DE TAREFAS ADVOCACIA")
        print("="*40)
        print("1. Adicionar Tarefa")
        print("2. Visualizar Tarefas Ativas (Por Prazo)")
        print("3. Marcar Tarefa como Conclu√≠da")
        print("4. Visualizar Tarefas Conclu√≠das")
        print("5. Remover Tarefa (permanente)")
        print("6. Visualizar Todas as Tarefas")
        print("7. Sair")
        print("="*40)
        
        escolha = input("Escolha uma op√ß√£o: ").strip()
        
        if escolha == '1':
            adicionar_tarefa(tarefas)
        elif escolha == '2':
            exibir_tarefas(tarefas, filtro="ativas")
        elif escolha == '3':
            marcar_concluida(tarefas)
        elif escolha == '4':
            exibir_tarefas(tarefas, filtro="concluidas")
        elif escolha == '5':
            remover_tarefa(tarefas)
        elif escolha == '6':
            exibir_tarefas(tarefas, filtro="todas")
        elif escolha == '7':
            print("Saindo do sistema. At√© breve!")
            break
        else:
            print("‚ùå Op√ß√£o inv√°lida. Tente novamente.")

if __name__ == "__main__":
    menu_principal()
